/* Auto-generated by reg_to_code.py from drv8311.yaml */

#pragma once
#include <stdint.h>

namespace drv8311_registers {

struct dev_sts1_register_t {
    /*  */
    uint8_t otp_flt;
    /*  */
    uint8_t reset;
    /*  */
    uint8_t spi_flt;
    /*  */
    uint8_t ocp;
    /*  */
    uint8_t uvp;
    /*  */
    uint8_t ot;
    /*  */
    uint8_t fault;

    uint16_t encode() const;
    static dev_sts1_register_t decode(uint16_t data);
    static uint32_t address() {
        return 0;
    }
    bool operator==(const dev_sts1_register_t& other) const;
    void print() const;
};

struct ot_sts_register_t {
    /*  */
    uint8_t ots_avdd;
    /*  */
    uint8_t otw;
    /*  */
    uint8_t otsd;

    uint16_t encode() const;
    static ot_sts_register_t decode(uint16_t data);
    static uint32_t address() {
        return 4;
    }
    bool operator==(const ot_sts_register_t& other) const;
    void print() const;
};

struct sup_sts_register_t {
    /*  */
    uint8_t csaref_uv;
    /*  */
    uint8_t cp_uv;
    /*  */
    uint8_t avdd_uv;
    /*  */
    uint8_t vinavdd_uv;

    uint16_t encode() const;
    static sup_sts_register_t decode(uint16_t data);
    static uint32_t address() {
        return 5;
    }
    bool operator==(const sup_sts_register_t& other) const;
    void print() const;
};

struct drv_sts_register_t {
    /*  */
    uint8_t ocpc_hs;
    /*  */
    uint8_t ocpb_hs;
    /*  */
    uint8_t ocpa_hs;
    /*  */
    uint8_t ocpc_ls;
    /*  */
    uint8_t ocpb_ls;
    /*  */
    uint8_t ocpa_ls;

    uint16_t encode() const;
    static drv_sts_register_t decode(uint16_t data);
    static uint32_t address() {
        return 6;
    }
    bool operator==(const drv_sts_register_t& other) const;
    void print() const;
};

struct sys_sts_register_t {
    /*  */
    uint8_t otpld_err;
    /*  */
    uint8_t spi_parity;
    /*  */
    uint8_t bus_cnt;
    /*  */
    uint8_t frm_err;

    uint16_t encode() const;
    static sys_sts_register_t decode(uint16_t data);
    static uint32_t address() {
        return 7;
    }
    bool operator==(const sys_sts_register_t& other) const;
    void print() const;
};

struct pwm_sync_prd_register_t {
    /*  */
    uint16_t pwm_sync_prd;

    uint16_t encode() const;
    static pwm_sync_prd_register_t decode(uint16_t data);
    static uint32_t address() {
        return 12;
    }
    bool operator==(const pwm_sync_prd_register_t& other) const;
    void print() const;
};

struct flt_mode_register_t {
    /*  */
    uint8_t otpflt_mode;
    /*  */
    uint8_t spflt_mode;
    /*  */
    uint8_t ocp_mode;
    /*  */
    uint8_t uvp_mode;
    /*  */
    uint8_t otsd_mode;

    uint16_t encode() const;
    static flt_mode_register_t decode(uint16_t data);
    static uint32_t address() {
        return 16;
    }
    bool operator==(const flt_mode_register_t& other) const;
    void print() const;
};

struct sysf_ctrl_register_t {
    /*  */
    uint8_t otavdd_en;
    /*  */
    uint8_t otw_en;
    /*  */
    uint8_t csarefuv_en;

    uint16_t encode() const;
    static sysf_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 18;
    }
    bool operator==(const sysf_ctrl_register_t& other) const;
    void print() const;
};

struct drvf_ctrl_register_t {
    /*  */
    uint8_t ocp_deg;
    /*  */
    uint8_t ocp_tblank;
    /*  */
    uint8_t ocp_lvl;

    uint16_t encode() const;
    static drvf_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 19;
    }
    bool operator==(const drvf_ctrl_register_t& other) const;
    void print() const;
};

struct flt_tctrl_register_t {
    /*  */
    uint8_t slow_tretry;
    /*  */
    uint8_t fast_tretry;

    uint16_t encode() const;
    static flt_tctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 22;
    }
    bool operator==(const flt_tctrl_register_t& other) const;
    void print() const;
};

struct flt_clr_register_t {
    /*  */
    uint8_t flt_clr;

    uint16_t encode() const;
    static flt_clr_register_t decode(uint16_t data);
    static uint32_t address() {
        return 23;
    }
    bool operator==(const flt_clr_register_t& other) const;
    void print() const;
};

struct pwmg_period_register_t {
    /*  */
    uint16_t pwm_prd_out;

    uint16_t encode() const;
    static pwmg_period_register_t decode(uint16_t data);
    static uint32_t address() {
        return 24;
    }
    bool operator==(const pwmg_period_register_t& other) const;
    void print() const;
};

struct pwmg_a_duty_register_t {
    /*  */
    uint16_t pwm_duty_outa;

    uint16_t encode() const;
    static pwmg_a_duty_register_t decode(uint16_t data);
    static uint32_t address() {
        return 25;
    }
    bool operator==(const pwmg_a_duty_register_t& other) const;
    void print() const;
};

struct pwmg_b_duty_register_t {
    /*  */
    uint16_t pwm_duty_outb;

    uint16_t encode() const;
    static pwmg_b_duty_register_t decode(uint16_t data);
    static uint32_t address() {
        return 26;
    }
    bool operator==(const pwmg_b_duty_register_t& other) const;
    void print() const;
};

struct pwmg_c_duty_register_t {
    /*  */
    uint16_t pwm_duty_outc;

    uint16_t encode() const;
    static pwmg_c_duty_register_t decode(uint16_t data);
    static uint32_t address() {
        return 27;
    }
    bool operator==(const pwmg_c_duty_register_t& other) const;
    void print() const;
};

enum class pwmc_state_enum {
    HIGH_OFF_LOW_OFF = 0,
    HIGH_OFF_LOW_ON = 1,
    HIGH_ON_LOW_OFF = 2,
    HIGH_OFF_LOW_PWM = 5,
    HIGH_PWM_LOW_OFF = 6,
    HIGH_PWM_LOW_INVERSE_PWM = 7,
};

enum class pwmb_state_enum {
    HIGH_OFF_LOW_OFF = 0,
    HIGH_OFF_LOW_ON = 1,
    HIGH_ON_LOW_OFF = 2,
    HIGH_OFF_LOW_PWM = 5,
    HIGH_PWM_LOW_OFF = 6,
    HIGH_PWM_LOW_INVERSE_PWM = 7,
};

enum class pwma_state_enum {
    HIGH_OFF_LOW_OFF = 0,
    HIGH_OFF_LOW_ON = 1,
    HIGH_ON_LOW_OFF = 2,
    HIGH_OFF_LOW_PWM = 5,
    HIGH_PWM_LOW_OFF = 6,
    HIGH_PWM_LOW_INVERSE_PWM = 7,
};

struct pwm_state_register_t {
    /*  */
    pwmc_state_enum pwmc_state;
    /*  */
    pwmb_state_enum pwmb_state;
    /*  */
    pwma_state_enum pwma_state;

    uint16_t encode() const;
    static pwm_state_register_t decode(uint16_t data);
    static uint32_t address() {
        return 28;
    }
    bool operator==(const pwm_state_register_t& other) const;
    void print() const;
};

enum class pwmcntr_mode_enum {
    UP_AND_DOWN = 0,
    UP = 1,
    DOWN = 2,
    NO_ACTION = 3,
};

enum class spiclk_freq_sync_enum {
    _1MHZ = 0,
    _1_25MHZ = 1,
    _2MHZ = 2,
    _2_5MHZ = 3,
    _4MHZ = 4,
    _5MHZ = 5,
    _8MHZ = 6,
    _10MHZ = 7,
};

enum class spisync_acrcy_enum {
    _512_CLOCK_CYCLES = 0,
    _256_CLOCK_CYCLES = 1,
    _128_CLOCK_CYCLES = 2,
    _64_CLOCK_CYCLES = 3,
};

struct pwmg_ctrl_register_t {
    /*  */
    uint8_t pwm_en;
    /*  */
    pwmcntr_mode_enum pwmcntr_mode;
    /* see options in datasheet */
    uint8_t pwm_osc_sync;
    /*  */
    spiclk_freq_sync_enum spiclk_freq_sync;
    /*  */
    spisync_acrcy_enum spisync_acrcy;

    uint16_t encode() const;
    static pwmg_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 29;
    }
    bool operator==(const pwmg_ctrl_register_t& other) const;
    void print() const;
};

enum class pwm_mode_enum {
    _6X_MODE = 0,
    _6X_MODE_DUPLICATE = 1,
    _3X_MODE = 2,
    _PWM_GENERATION_MODE = 3,
};

struct pwm_ctrl1_register_t {
    /*  */
    uint8_t ssc_dis;
    /*  */
    pwm_mode_enum pwm_mode;

    uint16_t encode() const;
    static pwm_ctrl1_register_t decode(uint16_t data);
    static uint32_t address() {
        return 32;
    }
    bool operator==(const pwm_ctrl1_register_t& other) const;
    void print() const;
};

enum class tdead_ctrl_enum {
    NO_DEADTIME = 0,
    _200NS = 1,
    _400NS = 2,
    _600NS = 3,
    _800NS = 4,
    _1US = 5,
    _1_2US = 6,
    _1_4US = 7,
};

enum class slew_rate_enum {
    _35_V_PER_US = 0,
    _75_V_PER_US = 1,
    _180_V_PER_US = 2,
    _230_V_PER_US = 3,
};

struct drv_ctrl_register_t {
    /*  */
    uint8_t dlycmp_en;
    /*  */
    tdead_ctrl_enum tdead_ctrl;
    /*  */
    slew_rate_enum slew_rate;

    uint16_t encode() const;
    static drv_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 34;
    }
    bool operator==(const drv_ctrl_register_t& other) const;
    void print() const;
};

enum class csa_gain_enum {
    _250_MV_PER_A = 0,
    _500_MV_PER_A = 1,
    _1_V_PER_A = 2,
    _2_V_PER_A = 3,
};

struct csa_ctrl_register_t {
    /*  */
    uint8_t csa_en;
    /*  */
    csa_gain_enum csa_gain;

    uint16_t encode() const;
    static csa_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 35;
    }
    bool operator==(const csa_ctrl_register_t& other) const;
    void print() const;
};

struct sys_ctrl_register_t {
    /*  */
    uint8_t write_key;
    /*  */
    uint8_t reg_lock;
    /*  */
    uint8_t spi_pen;

    uint16_t encode() const;
    static sys_ctrl_register_t decode(uint16_t data);
    static uint32_t address() {
        return 63;
    }
    bool operator==(const sys_ctrl_register_t& other) const;
    void print() const;
};

} // namespace drv8311_registers